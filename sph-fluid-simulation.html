<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPH Fluid Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #134e5e 0%, #71b280 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            max-width: 1200px;
        }

        h1 {
            text-align: center;
            color: #134e5e;
            margin-bottom: 5px;
            font-size: 2.2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .method-badge {
            text-align: center;
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            margin: 0 auto 20px;
            display: block;
            width: fit-content;
        }

        canvas {
            border: 3px solid #134e5e;
            border-radius: 10px;
            display: block;
            margin: 0 auto 20px;
            cursor: grab;
            background: #1a1a1a;
        }

        canvas:active {
            cursor: grabbing;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #495057;
            font-weight: 600;
            font-size: 0.85em;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .value-display {
            display: inline-block;
            background: #11998e;
            color: white;
            padding: 3px 10px;
            border-radius: 5px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(17, 153, 142, 0.4);
        }

        button.secondary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .info {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            border-radius: 5px;
            color: #155724;
            font-size: 0.9em;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 8px;
            text-align: center;
            flex: 1;
            min-width: 90px;
        }

        .stat-label {
            font-size: 0.75em;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #11998e;
        }

        .theory-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            border-radius: 5px;
            color: #0d47a1;
            font-size: 0.85em;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üíß SPH Fluid Simulation</h1>
        <p class="subtitle">Smoothed Particle Hydrodynamics - Lagrangian Method</p>
        <div class="method-badge">Particle-Based | Free Surface | Interactive</div>
        
        <canvas id="sphCanvas"></canvas>
        
        <div class="info">
            <strong>üéÆ T∆∞∆°ng t√°c:</strong> 
            <strong>Click chu·ªôt ph·∫£i</strong> ƒë·ªÉ ƒë·ªï n∆∞·ªõc! 
            <strong>Gi·ªØ chu·ªôt tr√°i</strong> ƒë·ªÉ t·∫°o v·∫≠t c·∫£n ƒë·ªông.
            M·ªói h·∫°t c√≥ kh·ªëi l∆∞·ª£ng, v·∫≠n t·ªëc, √°p su·∫•t v√† t∆∞∆°ng t√°c v·ªõi nhau qua kernel function!
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>
                    üí™ Gravity: <span class="value-display" id="gravityValue">-800</span>
                </label>
                <input type="range" id="gravity" min="-1500" max="-100" step="50" value="-800">
            </div>
            
            <div class="control-group">
                <label>
                    üíß Viscosity: <span class="value-display" id="viscosityValue">0.5</span>
                </label>
                <input type="range" id="viscosity" min="0" max="2" step="0.1" value="0.5">
            </div>
            
            <div class="control-group">
                <label>
                    üéØ Rest Density: <span class="value-display" id="densityValue">1000</span>
                </label>
                <input type="range" id="restDensity" min="500" max="2000" step="100" value="1000">
            </div>
            
            <div class="control-group">
                <label>
                    üîµ Particle Size: <span class="value-display" id="sizeValue">3</span>
                </label>
                <input type="range" id="particleSize" min="2" max="6" step="1" value="3">
            </div>
        </div>

        <div class="button-group">
            <button onclick="toggleSimulation()">‚èØÔ∏è Pause/Play</button>
            <button onclick="resetSimulation()">üîÑ Reset</button>
            <button onclick="addWaterBlock()">üíß Add Water</button>
            <button onclick="location.href='fluid-experiments.html'" class="secondary">üè† Back</button>
        </div>

        <div class="stats">
            <div class="stat-item">
                <span class="stat-label">FPS</span>
                <span class="stat-value" id="fpsValue">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Particles</span>
                <span class="stat-value" id="particleCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Avg Pressure</span>
                <span class="stat-value" id="pressureValue">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Max Velocity</span>
                <span class="stat-value" id="velocityValue">0</span>
            </div>
        </div>

        <div class="theory-box">
            <strong>üìê SPH Equations:</strong><br>
            <strong>1. Density:</strong> œÅ_i = Œ£ m_j W(r_ij, h)<br>
            <strong>2. Pressure Force:</strong> F_pressure = -Œ£ m_j (p_i + p_j)/(2œÅ_i œÅ_j) ‚àáW_ij<br>
            <strong>3. Viscosity Force:</strong> F_viscosity = Œº Œ£ m_j (v_j - v_i)/œÅ_j ‚àá¬≤W_ij<br>
            <strong>4. Kernel:</strong> W(r, h) = (315/64œÄh‚Åπ)(h¬≤ - r¬≤)¬≥ if r ‚â§ h, else 0
        </div>
    </div>

    <script>
        const canvas = document.getElementById('sphCanvas');
        const ctx = canvas.getContext('2d');
        
        const WIDTH = 800;
        const HEIGHT = 600;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        
        // SPH Parameters
        const H = 20;  // kernel radius
        const H2 = H * H;
        const MASS = 1.0;
        const GAS_CONST = 2000;  // pressure constant
        const EPSILON = 1e-6;
        
        let GRAVITY = -800;
        let VISCOSITY = 0.5;
        let REST_DENSITY = 1000;
        let PARTICLE_RENDER_SIZE = 3;
        let running = true;
        
        // Particle class
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.fx = 0;
                this.fy = 0;
                this.rho = REST_DENSITY;
                this.p = 0;
                this.neighbors = [];
            }
        }
        
        let particles = [];
        let obstacles = [];
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;
        let rightMouseDown = false;
        
        // Kernel functions
        function poly6Kernel(r2) {
            if (r2 >= H2) return 0;
            const temp = H2 - r2;
            return 315 / (64 * Math.PI * Math.pow(H, 9)) * temp * temp * temp;
        }
        
        function spikyGradient(dx, dy, r) {
            if (r >= H || r < EPSILON) return { x: 0, y: 0 };
            const temp = H - r;
            const factor = -45 / (Math.PI * Math.pow(H, 6)) * temp * temp / r;
            return { x: factor * dx, y: factor * dy };
        }
        
        function viscosityLaplacian(r) {
            if (r >= H) return 0;
            return 45 / (Math.PI * Math.pow(H, 6)) * (H - r);
        }
        
        // Find neighbors using spatial grid
        function findNeighbors() {
            const gridSize = H;
            const grid = new Map();
            
            // Build spatial grid
            for (let p of particles) {
                const gx = Math.floor(p.x / gridSize);
                const gy = Math.floor(p.y / gridSize);
                const key = `${gx},${gy}`;
                
                if (!grid.has(key)) grid.set(key, []);
                grid.get(key).push(p);
            }
            
            // Find neighbors
            for (let p of particles) {
                p.neighbors = [];
                const gx = Math.floor(p.x / gridSize);
                const gy = Math.floor(p.y / gridSize);
                
                // Check 9 cells
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const key = `${gx + dx},${gy + dy}`;
                        const cell = grid.get(key);
                        if (cell) {
                            for (let neighbor of cell) {
                                if (neighbor !== p) {
                                    const distX = p.x - neighbor.x;
                                    const distY = p.y - neighbor.y;
                                    const r2 = distX * distX + distY * distY;
                                    if (r2 < H2) {
                                        p.neighbors.push(neighbor);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Compute density and pressure
        function computeDensityPressure() {
            for (let p of particles) {
                p.rho = MASS * poly6Kernel(0); // self contribution
                
                for (let neighbor of p.neighbors) {
                    const dx = p.x - neighbor.x;
                    const dy = p.y - neighbor.y;
                    const r2 = dx * dx + dy * dy;
                    p.rho += MASS * poly6Kernel(r2);
                }
                
                // Equation of state: p = k(œÅ - œÅ‚ÇÄ)
                p.p = GAS_CONST * (p.rho - REST_DENSITY);
            }
        }
        
        // Compute forces
        function computeForces() {
            for (let p of particles) {
                let fx = 0;
                let fy = GRAVITY * p.rho; // gravity
                
                for (let neighbor of p.neighbors) {
                    const dx = p.x - neighbor.x;
                    const dy = p.y - neighbor.y;
                    const r = Math.sqrt(dx * dx + dy * dy + EPSILON);
                    
                    // Pressure force
                    const grad = spikyGradient(dx, dy, r);
                    const pressureFactor = -MASS * (p.p + neighbor.p) / (2 * neighbor.rho);
                    fx += pressureFactor * grad.x;
                    fy += pressureFactor * grad.y;
                    
                    // Viscosity force
                    const laplacian = viscosityLaplacian(r);
                    const viscosityFactor = VISCOSITY * MASS * (neighbor.vx - p.vx) / neighbor.rho;
                    fx += viscosityFactor * laplacian;
                    const viscosityFactorY = VISCOSITY * MASS * (neighbor.vy - p.vy) / neighbor.rho;
                    fy += viscosityFactorY * laplacian;
                }
                
                p.fx = fx;
                p.fy = fy;
            }
        }
        
        // Integrate
        function integrate() {
            const dt = 0.0005;
            
            for (let p of particles) {
                // Velocity Verlet integration
                p.vx += dt * p.fx / p.rho;
                p.vy += dt * p.fy / p.rho;
                
                p.x += dt * p.vx;
                p.y += dt * p.vy;
                
                // Boundary conditions
                const damping = 0.5;
                
                if (p.x < PARTICLE_RENDER_SIZE) {
                    p.x = PARTICLE_RENDER_SIZE;
                    p.vx *= -damping;
                }
                if (p.x > WIDTH - PARTICLE_RENDER_SIZE) {
                    p.x = WIDTH - PARTICLE_RENDER_SIZE;
                    p.vx *= -damping;
                }
                if (p.y < PARTICLE_RENDER_SIZE) {
                    p.y = PARTICLE_RENDER_SIZE;
                    p.vy *= -damping;
                }
                if (p.y > HEIGHT - PARTICLE_RENDER_SIZE) {
                    p.y = HEIGHT - PARTICLE_RENDER_SIZE;
                    p.vy *= -damping;
                }
                
                // Obstacle collision
                if (mouseDown) {
                    const dx = p.x - mouseX;
                    const dy = p.y - mouseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const radius = 40;
                    
                    if (dist < radius) {
                        const angle = Math.atan2(dy, dx);
                        p.x = mouseX + Math.cos(angle) * radius;
                        p.y = mouseY + Math.sin(angle) * radius;
                        p.vx = Math.cos(angle) * 100;
                        p.vy = Math.sin(angle) * 100;
                    }
                }
            }
        }
        
        // Simulation step
        function step() {
            if (!running) return;
            
            for (let iter = 0; iter < 3; iter++) {
                findNeighbors();
                computeDensityPressure();
                computeForces();
                integrate();
            }
        }
        
        // Render
        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // Draw particles
            for (let p of particles) {
                // Color by velocity
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                const hue = Math.min(240, 240 - speed / 5);
                const pressure = Math.max(0, Math.min(1, p.p / GAS_CONST));
                
                ctx.fillStyle = `hsl(${hue}, 80%, ${50 + pressure * 30}%)`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, PARTICLE_RENDER_SIZE, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw mouse obstacle
            if (mouseDown) {
                ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }
        
        // Update stats
        function updateStats() {
            document.getElementById('particleCount').textContent = particles.length;
            
            let totalPressure = 0;
            let maxVelocity = 0;
            
            for (let p of particles) {
                totalPressure += p.p;
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                maxVelocity = Math.max(maxVelocity, speed);
            }
            
            const avgPressure = particles.length > 0 ? totalPressure / particles.length : 0;
            document.getElementById('pressureValue').textContent = Math.round(avgPressure);
            document.getElementById('velocityValue').textContent = Math.round(maxVelocity);
        }
        
        // Animation loop
        let lastTime = performance.now();
        let frameCount = 0;
        
        function animate() {
            step();
            render();
            updateStats();
            
            // FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fpsValue').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            requestAnimationFrame(animate);
        }
        
        // Controls
        document.getElementById('gravity').addEventListener('input', (e) => {
            GRAVITY = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = e.target.value;
        });
        
        document.getElementById('viscosity').addEventListener('input', (e) => {
            VISCOSITY = parseFloat(e.target.value);
            document.getElementById('viscosityValue').textContent = e.target.value;
        });
        
        document.getElementById('restDensity').addEventListener('input', (e) => {
            REST_DENSITY = parseFloat(e.target.value);
            document.getElementById('densityValue').textContent = e.target.value;
        });
        
        document.getElementById('particleSize').addEventListener('input', (e) => {
            PARTICLE_RENDER_SIZE = parseFloat(e.target.value);
            document.getElementById('sizeValue').textContent = e.target.value;
        });
        
        function toggleSimulation() {
            running = !running;
        }
        
        function resetSimulation() {
            particles = [];
            addWaterBlock();
        }
        
        function addWaterBlock() {
            const startX = 100;
            const startY = 100;
            const spacing = 8;
            
            for (let y = 0; y < 15; y++) {
                for (let x = 0; x < 20; x++) {
                    particles.push(new Particle(
                        startX + x * spacing,
                        startY + y * spacing
                    ));
                }
            }
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            
            if (e.button === 0) {
                mouseDown = true;
            } else if (e.button === 2) {
                // Right click - add water
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 20;
                    particles.push(new Particle(
                        mouseX + Math.cos(angle) * dist,
                        mouseY + Math.sin(angle) * dist
                    ));
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Initialize
        addWaterBlock();
        animate();
    </script>
</body>
</html>
