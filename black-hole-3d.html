<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole 3D Animation - Enhanced</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', 'Segoe UI', sans-serif;
            background: #000;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            color: white;
            min-width: 280px;
            backdrop-filter: blur(10px);
            z-index: 100;
            transition: all 0.3s ease;
        }

        .controls-panel:hover {
            border-color: rgba(0, 212, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .controls-panel h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            font-weight: 700;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #aaa;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: #00d4ff;
        }

        .control-group select,
        .control-group button {
            width: 100%;
            padding: 8px;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid #00d4ff;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 0.9em;
        }

        .control-group button:hover {
            background: rgba(0, 212, 255, 0.3);
        }

        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-size: 0.85em;
            backdrop-filter: blur(10px);
            z-index: 100;
            transition: all 0.3s ease;
            font-family: 'Rajdhani', monospace;
        }

        .stats:hover {
            border-color: rgba(0, 212, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .stats div {
            margin: 5px 0;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            color: white;
            max-width: 350px;
            backdrop-filter: blur(10px);
            z-index: 100;
            transition: all 0.3s ease;
        }

        .info-panel:hover {
            border-color: rgba(0, 212, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .info-panel h3 {
            font-family: 'Orbitron', sans-serif;
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1.1em;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            font-weight: 700;
        }

        .info-panel p {
            font-size: 0.85em;
            line-height: 1.5;
            color: #ccc;
            margin-bottom: 8px;
        }

        .info-panel ul li {
            transition: color 0.3s ease;
        }

        .info-panel ul li:hover {
            color: #00d4ff;
        }

        .value-display {
            font-weight: bold;
            color: #00d4ff;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5em;
            z-index: 1000;
            text-align: center;
        }

        .loader {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="loading">
        <div class="loader"></div>
        <div>Loading Black Hole...</div>
    </div>

    <div class="controls-panel">
        <h2>âš« Black Hole Controls</h2>
        
        <div class="control-group">
            <label>Rotation Speed: <span id="rotationValue" class="value-display">1.0</span></label>
            <input type="range" id="rotationSpeed" min="0" max="5" step="0.1" value="1">
        </div>

        <div class="control-group">
            <label>Accretion Disk Size: <span id="diskSizeValue" class="value-display">3.0</span></label>
            <input type="range" id="diskSize" min="1" max="6" step="0.1" value="3">
        </div>

        <div class="control-group">
            <label>Particle Count: <span id="particleCountValue" class="value-display">5000</span></label>
            <input type="range" id="particleCount" min="1000" max="10000" step="500" value="5000">
        </div>

        <div class="control-group">
            <label>Camera View:</label>
            <select id="cameraView">
                <option value="orbit">Orbit View</option>
                <option value="front">Front View</option>
                <option value="side">Side View</option>
                <option value="top">Top View</option>
            </select>
        </div>

        <div class="control-group">
            <button id="resetBtn">Reset View</button>
        </div>

        <div class="control-group">
            <button id="toggleParticles">Toggle Particles</button>
        </div>
    </div>

    <div class="info-panel">
        <h3>ðŸŒŒ Black Hole Simulation</h3>
        <p>This is a 3D visualization of a black hole with its accretion disk and gravitational effects.</p>
        <p><strong>Features:</strong></p>
        <ul style="font-size: 0.85em; line-height: 1.8; color: #ccc;">
            <li>Event Horizon (core)</li>
            <li>Rotating Accretion Disk</li>
            <li>Particle jets & orbits</li>
            <li>Gravitational lensing effect</li>
            <li>Real-time shaders</li>
        </ul>
    </div>

    <div class="stats">
        <div>FPS: <span id="fps" class="value-display">60</span></div>
        <div>Particles: <span id="particlesActive" class="value-display">5000</span></div>
        <div>Time: <span id="timeElapsed" class="value-display">0.0</span>s</div>
    </div>

    <!-- Three.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Three.js addons - correct order with base Pass class first -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/ConvolutionShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <!-- GSAP for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <!-- Stats.js for performance monitoring - correct version -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/16/Stats.js"></script>
    
    <!-- Dat.GUI for better controls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    
    <script>
        // Three.js Scene Setup
        let scene, camera, renderer, blackHole, accretionDisk, particles, stars;
        let controls, composer, bloomPass, stats, gui;
        let rotationSpeed = 1.0;
        let diskSize = 3.0;
        let particleCount = 5000;
        let time = 0;
        let frameCount = 0;
        let lastTime = Date.now();
        let autoRotate = true;

        // Initialize
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 3, 8);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // OrbitControls for better camera interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 30;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // Post-processing with Bloom effect
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5,  // strength
                0.4,  // radius
                0.85  // threshold
            );
            composer.addPass(bloomPass);

            // Stats.js for FPS monitoring
            stats = new Stats();
            stats.showPanel(0); // 0: fps, 1: ms, 2: mb
            stats.dom.style.position = 'absolute';
            stats.dom.style.top = 'auto';
            stats.dom.style.bottom = '20px';
            stats.dom.style.right = '20px';
            stats.dom.style.left = 'auto';
            document.body.appendChild(stats.dom);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0x00d4ff, 2, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Create Black Hole Core (Event Horizon)
            createBlackHole();

            // Create Accretion Disk
            createAccretionDisk();

            // Create Particle Systems
            createParticles();

            // Create Background Stars
            createStars();

            // Setup dat.GUI
            setupGUI();

            // Event Listeners
            setupControls();
            window.addEventListener('resize', onWindowResize);

            // Hide loading with GSAP animation
            gsap.to('#loading', {
                opacity: 0,
                duration: 1,
                ease: "power2.inOut",
                onComplete: () => {
                    document.getElementById('loading').style.display = 'none';
                }
            });

            // Animate UI panels in
            gsap.from('.controls-panel', {
                x: -300,
                opacity: 0,
                duration: 1,
                delay: 0.5,
                ease: "power3.out"
            });

            gsap.from('.info-panel', {
                x: 300,
                opacity: 0,
                duration: 1,
                delay: 0.7,
                ease: "power3.out"
            });

            gsap.from('.stats', {
                y: 100,
                opacity: 0,
                duration: 1,
                delay: 0.9,
                ease: "power3.out"
            });

            // Animate camera in
            gsap.from(camera.position, {
                z: 20,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0, 0, 0)
            });

            // Start animation
            animate();
        }

        function createBlackHole() {
            // Event Horizon - Dark sphere with shader
            const geometry = new THREE.SphereGeometry(1, 64, 64);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color1: { value: new THREE.Color(0x000000) },
                    color2: { value: new THREE.Color(0x1a1a2e) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    
                    void main() {
                        float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                        vec3 color = mix(color1, color2, fresnel);
                        
                        // Add some subtle distortion
                        float noise = sin(vUv.x * 10.0 + time) * sin(vUv.y * 10.0 + time) * 0.1;
                        color += noise;
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });

            blackHole = new THREE.Mesh(geometry, material);
            scene.add(blackHole);

            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(1.2, 32, 32);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    glowColor: { value: new THREE.Color(0x00d4ff) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        gl_FragColor = vec4(glowColor, 1.0) * intensity;
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            scene.add(glow);
        }

        function createAccretionDisk() {
            const geometry = new THREE.RingGeometry(1.5, 4, 128, 64);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerColor: { value: new THREE.Color(0xff6b00) },
                    outerColor: { value: new THREE.Color(0x00d4ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 innerColor;
                    uniform vec3 outerColor;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        float dist = length(vPosition.xy);
                        float normalizedDist = (dist - 1.5) / (4.0 - 1.5);
                        
                        // Spiral pattern
                        float angle = atan(vPosition.y, vPosition.x);
                        float spiral = sin(angle * 8.0 - time * 2.0 + dist * 2.0);
                        
                        // Color gradient
                        vec3 color = mix(innerColor, outerColor, normalizedDist);
                        
                        // Add spiral brightness
                        color += spiral * 0.2;
                        
                        // Fade at edges
                        float alpha = 1.0 - normalizedDist;
                        alpha *= (0.8 + spiral * 0.2);
                        
                        gl_FragColor = vec4(color, alpha * 0.7);
                    }
                `,
                side: THREE.DoubleSide,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            accretionDisk = new THREE.Mesh(geometry, material);
            accretionDisk.rotation.x = Math.PI / 2 - 0.3; // Slight tilt
            scene.add(accretionDisk);
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                // Random orbital positions
                const theta = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 6;
                const y = (Math.random() - 0.5) * 2;

                positions.push(
                    Math.cos(theta) * radius,
                    y,
                    Math.sin(theta) * radius
                );

                // Color based on distance
                const colorIntensity = 1 - (radius / 8);
                colors.push(
                    0.2 + colorIntensity * 0.8,
                    0.5 + colorIntensity * 0.5,
                    1.0
                );

                // Orbital velocity
                velocities.push(1 / radius);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 1));

            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            for (let i = 0; i < 3000; i++) {
                positions.push(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );

                const brightness = Math.random();
                colors.push(brightness, brightness, brightness);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });

            stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        function updateParticles() {
            if (!particles) return;

            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array;

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 2];
                const radius = Math.sqrt(x * x + z * z);
                
                if (radius < 1.2) {
                    // Reset particle if too close to black hole
                    const theta = Math.random() * Math.PI * 2;
                    const newRadius = 5 + Math.random() * 3;
                    positions[i] = Math.cos(theta) * newRadius;
                    positions[i + 2] = Math.sin(theta) * newRadius;
                } else {
                    // Orbital motion
                    const angle = Math.atan2(z, x);
                    const velocity = velocities[i / 3] * rotationSpeed * 0.02;
                    const newAngle = angle + velocity;
                    
                    positions[i] = Math.cos(newAngle) * radius * 0.995; // Spiral in slowly
                    positions[i + 2] = Math.sin(newAngle) * radius * 0.995;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
        }

        function setupGUI() {
            gui = new dat.GUI({ width: 300 });
            gui.domElement.style.marginTop = '10px';

            const params = {
                rotationSpeed: 1.0,
                diskSize: 3.0,
                particleCount: 5000,
                bloomStrength: 1.5,
                bloomRadius: 0.4,
                bloomThreshold: 0.85,
                autoRotate: true,
                autoRotateSpeed: 0.5,
                resetView: function() {
                    gsap.to(camera.position, {
                        x: 0,
                        y: 3,
                        z: 8,
                        duration: 1.5,
                        ease: "power2.inOut",
                        onUpdate: () => camera.lookAt(0, 0, 0)
                    });
                },
                toggleParticles: function() {
                    if (particles) {
                        particles.visible = !particles.visible;
                    }
                }
            };

            // Black Hole Controls
            const blackHoleFolder = gui.addFolder('âš« Black Hole');
            blackHoleFolder.add(params, 'rotationSpeed', 0, 5, 0.1).name('Rotation Speed').onChange(value => {
                rotationSpeed = value;
                document.getElementById('rotationValue').textContent = value.toFixed(1);
            });
            blackHoleFolder.add(params, 'diskSize', 1, 6, 0.1).name('Disk Size').onChange(value => {
                diskSize = value;
                document.getElementById('diskSizeValue').textContent = value.toFixed(1);
                if (accretionDisk) {
                    gsap.to(accretionDisk.scale, {
                        x: diskSize / 3,
                        y: diskSize / 3,
                        duration: 0.8,
                        ease: "power2.out"
                    });
                }
            });
            blackHoleFolder.add(params, 'particleCount', 1000, 10000, 500).name('Particle Count').onChange(value => {
                particleCount = value;
                document.getElementById('particleCountValue').textContent = value;
                if (particles) {
                    scene.remove(particles);
                    createParticles();
                }
            });
            blackHoleFolder.add(params, 'toggleParticles').name('Toggle Particles');
            blackHoleFolder.open();

            // Post-Processing Controls
            const postFolder = gui.addFolder('âœ¨ Bloom Effects');
            postFolder.add(params, 'bloomStrength', 0, 3, 0.1).name('Bloom Strength').onChange(value => {
                bloomPass.strength = value;
            });
            postFolder.add(params, 'bloomRadius', 0, 1, 0.01).name('Bloom Radius').onChange(value => {
                bloomPass.radius = value;
            });
            postFolder.add(params, 'bloomThreshold', 0, 1, 0.01).name('Bloom Threshold').onChange(value => {
                bloomPass.threshold = value;
            });
            postFolder.open();

            // Camera Controls
            const cameraFolder = gui.addFolder('ðŸ“· Camera');
            cameraFolder.add(params, 'autoRotate').name('Auto Rotate').onChange(value => {
                controls.autoRotate = value;
                autoRotate = value;
            });
            cameraFolder.add(params, 'autoRotateSpeed', 0, 2, 0.1).name('Rotate Speed').onChange(value => {
                controls.autoRotateSpeed = value;
            });
            cameraFolder.add(params, 'resetView').name('Reset View');
            cameraFolder.open();
        }

        function setupControls() {
            // Rotation Speed
            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
                document.getElementById('rotationValue').textContent = rotationSpeed.toFixed(1);
            });

            // Disk Size
            document.getElementById('diskSize').addEventListener('input', (e) => {
                diskSize = parseFloat(e.target.value);
                document.getElementById('diskSizeValue').textContent = diskSize.toFixed(1);
                
                // Update accretion disk size with GSAP animation
                if (accretionDisk) {
                    gsap.to(accretionDisk.scale, {
                        x: diskSize / 3,
                        y: diskSize / 3,
                        duration: 0.8,
                        ease: "power2.out"
                    });
                }
            });

            // Particle Count
            document.getElementById('particleCount').addEventListener('input', (e) => {
                particleCount = parseInt(e.target.value);
                document.getElementById('particleCountValue').textContent = particleCount;
                
                // Recreate particles
                if (particles) {
                    scene.remove(particles);
                    createParticles();
                }
            });

            // Camera View with smooth GSAP transitions
            document.getElementById('cameraView').addEventListener('change', (e) => {
                const view = e.target.value;
                let targetPos = { x: 0, y: 3, z: 8 };
                
                switch(view) {
                    case 'orbit':
                        targetPos = { x: 0, y: 3, z: 8 };
                        break;
                    case 'front':
                        targetPos = { x: 0, y: 0, z: 10 };
                        break;
                    case 'side':
                        targetPos = { x: 10, y: 0, z: 0 };
                        break;
                    case 'top':
                        targetPos = { x: 0, y: 10, z: 0 };
                        break;
                }
                
                gsap.to(camera.position, {
                    x: targetPos.x,
                    y: targetPos.y,
                    z: targetPos.z,
                    duration: 1.5,
                    ease: "power2.inOut",
                    onUpdate: () => camera.lookAt(0, 0, 0)
                });
            });

            // Reset Button with smooth animation
            document.getElementById('resetBtn').addEventListener('click', () => {
                gsap.to(camera.position, {
                    x: 0,
                    y: 3,
                    z: 8,
                    duration: 1.5,
                    ease: "power2.inOut",
                    onUpdate: () => camera.lookAt(0, 0, 0)
                });
                
                gsap.to({ value: rotationSpeed }, {
                    value: 1.0,
                    duration: 1,
                    onUpdate: function() {
                        rotationSpeed = this.targets()[0].value;
                        document.getElementById('rotationSpeed').value = rotationSpeed;
                        document.getElementById('rotationValue').textContent = rotationSpeed.toFixed(1);
                    }
                });
            });

            // Toggle Particles
            document.getElementById('toggleParticles').addEventListener('click', () => {
                if (particles) {
                    particles.visible = !particles.visible;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update Stats.js
            stats.begin();

            time += 0.016; // Approximately 60 FPS

            // Update shader uniforms
            if (blackHole && blackHole.material.uniforms) {
                blackHole.material.uniforms.time.value = time;
            }

            if (accretionDisk && accretionDisk.material.uniforms) {
                accretionDisk.material.uniforms.time.value = time;
                accretionDisk.rotation.z += 0.001 * rotationSpeed;
            }

            // Update particles
            updateParticles();

            // Update OrbitControls
            if (controls) {
                controls.update();
            }

            // Rotate stars slowly
            if (stars) {
                stars.rotation.y += 0.0001;
            }

            // Update custom stats display
            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
            document.getElementById('timeElapsed').textContent = time.toFixed(1);
            document.getElementById('particlesActive').textContent = particleCount;

            // Render with post-processing
            composer.render();

            stats.end();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
