<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vorticity Confinement Fluid Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #4a148c 0%, #6a1b9a 50%, #8e24aa 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 1200px;
        }

        h1 {
            text-align: center;
            color: #4a148c;
            margin-bottom: 5px;
            font-size: 2.2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .method-badge {
            text-align: center;
            background: linear-gradient(135deg, #8e24aa, #d81b60);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            margin: 0 auto 20px;
            display: block;
            width: fit-content;
        }

        canvas {
            border: 3px solid #4a148c;
            border-radius: 10px;
            display: block;
            margin: 0 auto 20px;
            cursor: crosshair;
            background: #000;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #495057;
            font-weight: 600;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .value-display {
            display: inline-block;
            background: #8e24aa;
            color: white;
            padding: 3px 10px;
            border-radius: 5px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            background: linear-gradient(135deg, #8e24aa 0%, #d81b60 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(142, 36, 170, 0.4);
        }

        button.secondary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .info {
            background: #f3e5f5;
            border-left: 4px solid #8e24aa;
            padding: 15px;
            border-radius: 5px;
            color: #4a148c;
            font-size: 0.9em;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 8px;
            text-align: center;
            flex: 1;
            min-width: 110px;
        }

        .stat-label {
            font-size: 0.75em;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #8e24aa;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .comparison-item {
            background: #e8eaf6;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .comparison-item.standard {
            border-color: #f44336;
        }

        .comparison-item.confinement {
            border-color: #4caf50;
        }

        .comparison-item h4 {
            margin-top: 0;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üå™Ô∏è Vorticity Confinement</h1>
        <p class="subtitle">Enhanced Turbulence Preservation with Confinement Forces</p>
        <div class="method-badge">Euler + Vorticity Confinement = Sharp Vortices!</div>
        
        <canvas id="fluidCanvas"></canvas>
        
        <div class="info">
            <strong>üéØ Vorticity Confinement:</strong> 
            Ph∆∞∆°ng ph√°p n√†y th√™m <strong>l·ª±c confinement</strong> ƒë·ªÉ ch·ªëng l·∫°i numerical dissipation.
            Xo√°y ƒë∆∞·ª£c gi·ªØ l·∫°i s·∫Øc n√©t h∆°n nhi·ªÅu so v·ªõi Euler thu·∫ßn! 
            ƒêi·ªÅu ch·ªânh <strong>Confinement Strength</strong> ƒë·ªÉ th·∫•y s·ª± kh√°c bi·ªát.
        </div>

        <div class="comparison">
            <div class="comparison-item standard">
                <h4>‚ùå Standard Euler (Œµ = 0)</h4>
                <p style="font-size: 0.85em; color: #666;">Xo√°y b·ªã tan d·∫ßn do numerical diffusion</p>
            </div>
            <div class="comparison-item confinement">
                <h4>‚úÖ With Confinement (Œµ > 0)</h4>
                <p style="font-size: 0.85em; color: #666;">Xo√°y s·∫Øc n√©t, turbulence preserved!</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>
                    üåÄ Confinement Strength (Œµ): <span class="value-display" id="confinementValue">0.05</span>
                </label>
                <input type="range" id="confinementStrength" min="0" max="0.2" step="0.01" value="0.05">
            </div>
            
            <div class="control-group">
                <label>
                    üí® Inlet Velocity: <span class="value-display" id="velocityValue">6.0</span>
                </label>
                <input type="range" id="inletVelocity" min="1" max="15" step="0.5" value="6">
            </div>
            
            <div class="control-group">
                <label>
                    üéØ Resolution: <span class="value-display" id="resolutionValue">High</span>
                </label>
                <input type="range" id="resolution" min="0" max="2" step="1" value="2">
                <div style="display: flex; justify-content: space-between; font-size: 0.7em; color: #666; margin-top: 3px;">
                    <span>Low</span>
                    <span>Med</span>
                    <span>High</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>
                    üíß Smoke Density: <span class="value-display" id="densityValue">60</span>
                </label>
                <input type="range" id="smokeDensity" min="10" max="100" step="5" value="60">
            </div>
        </div>

        <div class="button-group">
            <button onclick="toggleSimulation()">‚èØÔ∏è Pause/Play</button>
            <button onclick="resetSimulation()">üîÑ Reset</button>
            <button onclick="location.href='fluid-experiments.html'" class="secondary">üè† All Experiments</button>
        </div>

        <div class="stats">
            <div class="stat-item">
                <span class="stat-label">FPS</span>
                <span class="stat-value" id="fpsValue">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Grid Size</span>
                <span class="stat-value" id="gridSize">240 √ó 150</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Avg Vorticity</span>
                <span class="stat-value" id="vorticityValue">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Confinement</span>
                <span class="stat-value" id="statusValue">ON</span>
            </div>
        </div>

        <div style="background: #fff8e1; border-left: 4px solid #ffc107; padding: 15px; border-radius: 5px; font-size: 0.85em; line-height: 1.6; color: #856404;">
            <strong>üìê Vorticity Confinement Force:</strong><br>
            <strong>1. Compute vorticity:</strong> œâ = ‚àá √ó u = (‚àÇu_y/‚àÇx - ‚àÇu_x/‚àÇy)<br>
            <strong>2. Normalized vorticity gradient:</strong> N = ‚àá|œâ| / |‚àá|œâ||<br>
            <strong>3. Confinement force:</strong> f_conf = Œµ¬∑h¬∑(N √ó œâ)<br>
            <strong>4. Add to velocity:</strong> u += Œît¬∑f_conf<br><br>
            L·ª±c n√†y "ƒë·∫©y" xo√°y v·ªÅ ph√≠a gradient c·ªßa vorticity magnitude, ch·ªëng l·∫°i dissipation!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('fluidCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        const WIDTH = 800;
        const HEIGHT = 500;
        
        const RESOLUTION_PRESETS = [
            { name: 'Low', width: 160, height: 100 },
            { name: 'Medium', width: 200, height: 125 },
            { name: 'High', width: 240, height: 150 }
        ];
        
        let GRID_WIDTH = RESOLUTION_PRESETS[2].width;
        let GRID_HEIGHT = RESOLUTION_PRESETS[2].height;
        let CELL_SIZE = WIDTH / GRID_WIDTH;
        
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        
        let running = true;
        
        class VorticityConfinementFluid {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.size = width * height;
                
                this.u = new Float32Array(this.size);
                this.v = new Float32Array(this.size);
                this.u_prev = new Float32Array(this.size);
                this.v_prev = new Float32Array(this.size);
                
                this.density = new Float32Array(this.size);
                this.density_prev = new Float32Array(this.size);
                
                this.pressure = new Float32Array(this.size);
                this.divergence = new Float32Array(this.size);
                
                this.vorticity = new Float32Array(this.size);
                
                this.obstacle = new Array(this.size).fill(false);
                
                this.dt = 0.016;
                this.inletVelocity = 6.0;
                this.smokeDensity = 60;
                this.confinementStrength = 0.05;
                this.projectionIterations = 20;
                
                this.obstacleX = WIDTH / 3;
                this.obstacleY = HEIGHT / 2;
                this.obstacleRadius = 40;
                this.pipeWidth = 60;
                
                this.setupObstacle();
            }
            
            IX(x, y) {
                x = Math.max(0, Math.min(this.width - 1, Math.floor(x)));
                y = Math.max(0, Math.min(this.height - 1, Math.floor(y)));
                return x + y * this.width;
            }
            
            setupObstacle() {
                this.obstacle.fill(false);
                const obstacleGridX = (this.obstacleX / WIDTH) * this.width;
                const obstacleGridY = (this.obstacleY / HEIGHT) * this.height;
                const r = this.obstacleRadius / CELL_SIZE;
                
                for (let i = 0; i < this.width; i++) {
                    for (let j = 0; j < this.height; j++) {
                        const dx = i - obstacleGridX;
                        const dy = j - obstacleGridY;
                        if (dx*dx + dy*dy <= r*r) {
                            this.obstacle[this.IX(i, j)] = true;
                        }
                    }
                }
            }
            
            addInletSource() {
                const pipeGridWidth = Math.floor((this.pipeWidth / WIDTH) * this.width);
                const pipeGridY = Math.floor((HEIGHT / 2 / HEIGHT) * this.height);
                const pipeStartY = Math.floor(pipeGridY - pipeGridWidth / 2);
                const pipeEndY = Math.floor(pipeGridY + pipeGridWidth / 2);
                
                for (let j = pipeStartY; j <= pipeEndY; j++) {
                    if (j >= 0 && j < this.height) {
                        for (let i = 0; i < 3; i++) {
                            const idx = this.IX(i, j);
                            this.u[idx] = this.inletVelocity;
                            this.v[idx] = 0;
                            this.density[idx] = this.smokeDensity;
                        }
                    }
                }
            }
            
            advect(field, field_prev, u, v) {
                const dt0 = this.dt * Math.max(this.width, this.height);
                
                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = this.IX(i, j);
                        if (this.obstacle[idx]) continue;
                        
                        let x = i - dt0 * u[idx];
                        let y = j - dt0 * v[idx];
                        
                        x = Math.max(0.5, Math.min(this.width - 1.5, x));
                        y = Math.max(0.5, Math.min(this.height - 1.5, y));
                        
                        const i0 = Math.floor(x);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(y);
                        const j1 = j0 + 1;
                        
                        const s1 = x - i0;
                        const s0 = 1 - s1;
                        const t1 = y - j0;
                        const t0 = 1 - t1;
                        
                        field[idx] = s0 * (t0 * field_prev[this.IX(i0, j0)] + 
                                          t1 * field_prev[this.IX(i0, j1)]) +
                                    s1 * (t0 * field_prev[this.IX(i1, j0)] + 
                                          t1 * field_prev[this.IX(i1, j1)]);
                    }
                }
            }
            
            // Compute vorticity: œâ = ‚àÇv/‚àÇx - ‚àÇu/‚àÇy
            computeVorticity() {
                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = this.IX(i, j);
                        if (this.obstacle[idx]) {
                            this.vorticity[idx] = 0;
                            continue;
                        }
                        
                        const dvdx = (this.v[this.IX(i + 1, j)] - this.v[this.IX(i - 1, j)]) * 0.5;
                        const dudy = (this.u[this.IX(i, j + 1)] - this.u[this.IX(i, j - 1)]) * 0.5;
                        
                        this.vorticity[idx] = dvdx - dudy;
                    }
                }
            }
            
            // Apply vorticity confinement force
            applyVorticityConfinement() {
                if (this.confinementStrength === 0) return;
                
                const dx = 1.0;
                const epsilon = this.confinementStrength;
                
                for (let j = 2; j < this.height - 2; j++) {
                    for (let i = 2; i < this.width - 2; i++) {
                        const idx = this.IX(i, j);
                        if (this.obstacle[idx]) continue;
                        
                        // Compute gradient of vorticity magnitude
                        const omegaL = Math.abs(this.vorticity[this.IX(i - 1, j)]);
                        const omegaR = Math.abs(this.vorticity[this.IX(i + 1, j)]);
                        const omegaB = Math.abs(this.vorticity[this.IX(i, j - 1)]);
                        const omegaT = Math.abs(this.vorticity[this.IX(i, j + 1)]);
                        
                        const dwdx = (omegaR - omegaL) * 0.5 / dx;
                        const dwdy = (omegaT - omegaB) * 0.5 / dx;
                        
                        // Normalized gradient
                        const length = Math.sqrt(dwdx * dwdx + dwdy * dwdy) + 1e-5;
                        const Nx = dwdx / length;
                        const Ny = dwdy / length;
                        
                        // Confinement force: f = Œµ¬∑h¬∑(N √ó œâ)
                        // In 2D: f_x = Œµ¬∑h¬∑N_y¬∑œâ, f_y = -Œµ¬∑h¬∑N_x¬∑œâ
                        const omega = this.vorticity[idx];
                        this.u[idx] += this.dt * epsilon * dx * Ny * omega;
                        this.v[idx] -= this.dt * epsilon * dx * Nx * omega;
                    }
                }
            }
            
            project() {
                const h = 1.0;
                
                // Compute divergence
                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = this.IX(i, j);
                        
                        if (this.obstacle[idx]) {
                            this.divergence[idx] = 0;
                            this.pressure[idx] = 0;
                            continue;
                        }
                        
                        this.divergence[idx] = -0.5 * h * (
                            this.u[this.IX(i + 1, j)] - this.u[this.IX(i - 1, j)] +
                            this.v[this.IX(i, j + 1)] - this.v[this.IX(i, j - 1)]
                        );
                        this.pressure[idx] = 0;
                    }
                }
                
                // Jacobi iteration
                for (let iter = 0; iter < this.projectionIterations; iter++) {
                    const pressure_old = new Float32Array(this.pressure);
                    
                    for (let j = 1; j < this.height - 1; j++) {
                        for (let i = 1; i < this.width - 1; i++) {
                            const idx = this.IX(i, j);
                            if (this.obstacle[idx]) continue;
                            
                            this.pressure[idx] = (
                                this.divergence[idx] +
                                pressure_old[this.IX(i - 1, j)] +
                                pressure_old[this.IX(i + 1, j)] +
                                pressure_old[this.IX(i, j - 1)] +
                                pressure_old[this.IX(i, j + 1)]
                            ) / 4.0;
                        }
                    }
                }
                
                // Subtract gradient
                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = this.IX(i, j);
                        if (this.obstacle[idx]) {
                            this.u[idx] = 0;
                            this.v[idx] = 0;
                            continue;
                        }
                        
                        this.u[idx] -= 0.5 * (this.pressure[this.IX(i + 1, j)] - 
                                              this.pressure[this.IX(i - 1, j)]) / h;
                        this.v[idx] -= 0.5 * (this.pressure[this.IX(i, j + 1)] - 
                                              this.pressure[this.IX(i, j - 1)]) / h;
                    }
                }
            }
            
            step() {
                this.addInletSource();
                
                this.u_prev.set(this.u);
                this.v_prev.set(this.v);
                this.density_prev.set(this.density);
                
                this.advect(this.u, this.u_prev, this.u_prev, this.v_prev);
                this.advect(this.v, this.v_prev, this.u_prev, this.v_prev);
                
                // VORTICITY CONFINEMENT - The magic happens here!
                this.computeVorticity();
                this.applyVorticityConfinement();
                
                this.project();
                
                this.advect(this.density, this.density_prev, this.u, this.v);
                
                for (let i = 0; i < this.size; i++) {
                    this.density[i] *= 0.995;
                }
            }
            
            reset() {
                this.u.fill(0);
                this.v.fill(0);
                this.density.fill(0);
                this.pressure.fill(0);
                this.vorticity.fill(0);
            }
        }
        
        let fluid = new VorticityConfinementFluid(GRID_WIDTH, GRID_HEIGHT);
        
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            const imageData = ctx.createImageData(WIDTH, HEIGHT);
            const data = imageData.data;
            
            for (let j = 0; j < GRID_HEIGHT; j++) {
                for (let i = 0; i < GRID_WIDTH; i++) {
                    const idx = fluid.IX(i, j);
                    const d = Math.min(255, fluid.density[idx]);
                    
                    // Color based on vorticity too
                    const vort = Math.abs(fluid.vorticity[idx]);
                    const r = Math.floor(d * 0.7 + vort * 30);
                    const g = Math.floor(d * 0.8 + vort * 20);
                    const b = Math.floor(Math.min(255, d * 1.2));
                    
                    const x = Math.floor(i * CELL_SIZE);
                    const y = Math.floor(j * CELL_SIZE);
                    const endX = Math.floor((i + 1) * CELL_SIZE);
                    const endY = Math.floor((j + 1) * CELL_SIZE);
                    
                    for (let py = y; py < endY; py++) {
                        for (let px = x; px < endX; px++) {
                            if (px < WIDTH && py < HEIGHT) {
                                const pixelIdx = (py * WIDTH + px) * 4;
                                data[pixelIdx] = r;
                                data[pixelIdx + 1] = g;
                                data[pixelIdx + 2] = b;
                                data[pixelIdx + 3] = 255;
                            }
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Draw obstacle
            ctx.fillStyle = '#ff6b6b';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(fluid.obstacleX, fluid.obstacleY, fluid.obstacleRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw inlet
            ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.fillRect(0, HEIGHT/2 - fluid.pipeWidth/2, 30, fluid.pipeWidth);
        }
        
        let lastTime = performance.now();
        let frameCount = 0;
        
        function animate() {
            if (running) fluid.step();
            render();
            
            // Stats
            let totalVort = 0;
            for (let i = 0; i < fluid.size; i++) {
                totalVort += Math.abs(fluid.vorticity[i]);
            }
            document.getElementById('vorticityValue').textContent = (totalVort / fluid.size).toFixed(2);
            document.getElementById('statusValue').textContent = fluid.confinementStrength > 0 ? 'ON' : 'OFF';
            
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fpsValue').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            requestAnimationFrame(animate);
        }
        
        // Controls
        document.getElementById('confinementStrength').addEventListener('input', (e) => {
            fluid.confinementStrength = parseFloat(e.target.value);
            document.getElementById('confinementValue').textContent = e.target.value;
        });
        
        document.getElementById('inletVelocity').addEventListener('input', (e) => {
            fluid.inletVelocity = parseFloat(e.target.value);
            document.getElementById('velocityValue').textContent = e.target.value;
        });
        
        document.getElementById('smokeDensity').addEventListener('input', (e) => {
            fluid.smokeDensity = parseFloat(e.target.value);
            document.getElementById('densityValue').textContent = e.target.value;
        });
        
        document.getElementById('resolution').addEventListener('input', (e) => {
            const idx = parseInt(e.target.value);
            const preset = RESOLUTION_PRESETS[idx];
            
            GRID_WIDTH = preset.width;
            GRID_HEIGHT = preset.height;
            CELL_SIZE = WIDTH / GRID_WIDTH;
            
            document.getElementById('resolutionValue').textContent = preset.name;
            document.getElementById('gridSize').textContent = `${GRID_WIDTH} √ó ${GRID_HEIGHT}`;
            
            const oldParams = {
                inletVelocity: fluid.inletVelocity,
                smokeDensity: fluid.smokeDensity,
                confinementStrength: fluid.confinementStrength
            };
            
            fluid = new VorticityConfinementFluid(GRID_WIDTH, GRID_HEIGHT);
            Object.assign(fluid, oldParams);
            fluid.setupObstacle();
        });
        
        function toggleSimulation() {
            running = !running;
        }
        
        function resetSimulation() {
            fluid.reset();
        }
        
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            fluid.obstacleX = e.clientX - rect.left;
            fluid.obstacleY = e.clientY - rect.top;
            fluid.setupObstacle();
        });
        
        animate();
    </script>
</body>
</html>
